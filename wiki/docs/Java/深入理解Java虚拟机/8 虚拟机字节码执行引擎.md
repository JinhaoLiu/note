---
title: 8 虚拟机字节码执行引擎
toc: false
date: 2017-10-30
---

执⾏引擎是Java虚拟机最核⼼的组成部分之⼀。“虚拟机”是⼀个相对于"物理机"的概念，这两种机器都有代码执⾏能⼒，其区别是物理机的执⾏引擎是直接建⽴在处理器、硬件、指令集和操作系统层⾯上的，⽽虚拟机的执⾏引擎则是由⾃⼰实现的，因此可以⾃⾏制定指令集与执⾏引擎的结构体系，并且能够执⾏那些不被硬件直接⽀持的指令集格式。

在不同的虚拟机实现⾥⾯，执⾏引擎在执⾏Java代码的时候可能会有解释执⾏（通过解释器执⾏）和编译执⾏（通过即时编译器产⽣本地代码执⾏）两种选择， 也可能两者兼备，甚⾄还可能会包含⼏个不同级别的编译器执⾏引擎。

为了能更高效的执行，同时又保持跨平台的特性，另外一个方法就是在执行class时再将其翻译为对应的机器码，这个方法是比较靠谱的，因此无论是Hotspot、还是JRockit，都采用了这种方式，也就是大家熟知的JIT(Just In Time) Compiler。



JAVA的第一道工序是javac编译，当然目标文件是字节码BYTECODE。后续可能有三种处理方式：

1. 运行时，BYTECODE由JVM逐条解释执行(通过解释器执行)
2. 运行时，部分代码可能由JIT(Just In Time)翻译为目标机器指令（以method为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行；
3. RTSJ。继JAVAC之后执行AOT二次编译，生成静态的目标平台代码（典型的就是IBM WEBSHPERE REAL TIME）。

OK，既然觉得在装载class后翻译成机器码去执行可以比较高效，那这个时候又会出现两种状况，是执行class的时候就立刻翻译成机器码，还是先用解释模式执行，然后到一定时机再翻译成机器码呢，之所以出现这两种状况，原因在于将class翻译为机器码是需要消耗时间的，因此如果执行class 的时候就立刻翻译成机器码的话，也就会导致Java程序启动速度会比较慢，JRockit是这么认为的，JRockit的服务对象是server级应用，这类应用的特点是没那么在乎启动速度，而更在乎的是执行时的高效，而且如果执行的时候就立刻翻译成机器码的话，就意味着压根不需要实现解释器，因此 JRockit采取的方法是在执行class时直接编译为机器码，而Hotspot由于需要同时支持client和server应用，对于client应用而言，启动速度非常重要，因此Hotspot采用的是先解释执行，到了一定时机后再翻译成机器码。

详见 JRockit权威指南--深入理解JVM 第二章