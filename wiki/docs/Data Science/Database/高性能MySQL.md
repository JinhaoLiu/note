---
title: 高性能MySQL
---

### 1 MySQL架构和历史

MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理(Query Processing)及其他系统任务(Server Task)和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储方式。

#### MySQL逻辑架构


![mySQL逻辑架构](figures/mySQL_structure.png)


当客户端链接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。随后MySQL会解析查询，并创建内部数据结构(解析树)，然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。优化器会请求存储引擎提供容量或者某个具体操作的开销信息等。


#### 并发控制

在处理并发读或者写时，可以通过由读锁(read lock)和写锁(write lock)组成的锁系统来解决。读锁是共享的，多个客户在同一时刻可以同时读取同一资源，而互不干扰。写锁是排他的，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。所谓的**锁策略**，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

**表锁**(table lock)是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。用户在对表进行写操作(插入、删除、更新等)前，需要先获得锁，这会阻塞其他用户对该表的所有读写操作。

**行级锁**(row lock)可以最大程度地支持并发处理，同时也带来了最大的锁开销。在InnoDB和XtraDB等存储引擎中实现了行级锁。

#### 事务

**事务**(transaction)是数据库应用中完成单一逻辑功能的操作集合。



##### ACID特性

关系型数据库的事务具有ACID特性，即**原子性**(Atomicity)，**一致性**(Consistency)，**隔离性**(Isolation)，**持久性**(Durability)。

![](figures/ACID.jpg)


* 事务的**原子性**是指事务是一个**不可再分割的最小工作单元**，整个事务中的所有操作要么都执行，要么都不执行，不可能只执行其中的一部分。例如资金从账户A转账到账户B时，需要在账户A中进行取出操作，在账户B中进行存入操作。这两个操作必须保证要么都发生要么都不发生。
* 事务的**一致性**是指数据库总是从一个一致性的状态转换到另外一个一致性的状态。例如资金转账前后，账户A和B的余额之和应该是保持不变的。
* 事务的**隔离性**是指一个事务所做的修改在最终提交以前，对其他事务是不可见的。
* 事务的**持久性**是指事务执行完成后，该事务对数据库的更改就会永久保存到数据库中。例如当资金转账成功后，即使发生系统故障，账户A、B的余额也应该保持转账成功结束后的新值。



##### 隔离级别

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

* **未提交读**(READ UNCOMMITTED): 事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为**脏读**(dirty read)。在实际应用中一般很少使用。
* **提交读**(READ COMMITTED): 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为执行两次同样查询，可能得到不一样的结果。
* **可重复读**(REPEATABLE READ): 在同一个事务中多次读取同样记录的结果是一致的。但无法解决**幻读**(phantom read)的问题: 当某个事务在读取某个范围内的记录时，另外⼀个事务又在该范围内插⼊了新的记录，当之前的事务再次读取该范围的记录时，会产⽣幻⾏。InnoDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。
* **序列化读**(SERIAZABLE)：所有的事务操作都必须串行操作。这种隔离级别最高，但是牺牲了系统的并发性。简单来说，序列化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

![](figures/transaction_isolation_level.jpg)



##### 死锁

MySQL实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖并立即返回一个错误。InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。

锁的行为和顺序是和存储引擎相关的。死锁的产生有双重原因：有些因为真正的数据冲突，但有些完全是由于存储引擎的实现方式导致的。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。


##### MySQL中的事务

MySQL默认采用自动提交(autocommit)模式：如果不是显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，这时该事务结束，同时又开始了另外一个事务。

MySQL服务器层不管理个事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。如果在事务中混合使用了事务型和非事务型表(例如InnoDB和MyISAM表)，该事务需要回滚，那么非事务型的表的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复。


#### 多版本并发控制

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于并发性能的考虑，它们一般都同时实现了**多版本并发控制**(MVCC)。可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销耕地。


MVCC的实现，是通过保存数据在某个时间点的快照实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，⽤来和查询到的每⾏记录的版本号进⾏⽐较。


下⾯看⼀下在可重复读的隔离级别下，MVCC具体是怎么进行读操作的。

InnoDB会根据以下两个条件检查每⾏记录：

* InnoDB只查找版本早于当前事务版本的数据⾏（也就是，⾏的系统版本号⼩于或等于事务的系统版本号），这样可以确保事务读取的⾏，要么是在事务开始前已经存在的，要么是事务⾃⾝插⼊或者修改过的。
* ⾏的删除版本要么未定义，要么⼤于当前事务版本号。这可以确保事务读取到的⾏，在事务开始之前未被删除。

只有符合上述两个条件的记录，才能返回作为查询结果。保存这两个额外系统版本号，使⼤多数读操作都可以不⽤加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的⾏。

#### MySQL的存储引擎

在文件系统中，MySQL将每个数据库(也可以称之为schema)保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。



##### InnoDB

InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期(short-lived)事务，短期事务大部分情况是正常提交的，很少会被回滚。除非有非常特别的愿意需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。

InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。InnoDB采用MVCC来控制高并发，并且实现了四个标准的隔离级别，其默认级别是可重复读，并且通过间隙锁(next-key locking)策略防止幻读的出现。

InnoDB表是基于聚簇索引建立的，对主键查询有很高的性能。


#### MyISAM

MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全回复。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等。

### 2 MySQL基准测试

基准测试是针对系统设计的一种压力测试。通常的目标是为了掌握系统的行为。基准测试不是真实的压力测试，相对来说比较简单。真实压力是不可预期且变化多端的，有时候情况会过于复杂而难以解释。



### 3 服务器性能剖析
### 4 Schema与数据库类型优化
### 5 创建高性能的索引
### 6 查询性能优化

数据库结构优化的目的

减少数据冗余
尽量避免数据维护中出现更新，插入和删除异常
节约数据存储空间
提高查询效率


数据库结构设计的步骤

需求分析：全面了解产品设计的存储需求
逻辑设计：设计数据的逻辑存储结构
物理设计：根据所使用的数据库特点进行表结构设计
维护优化：根据实际情况对索引、存储结构进行优化



数据库设计范式

为了设计出没有数据冗余和数据维护异常的数据库结构

数据库三范式

数据库设计的第一范式

* 数据库表中的所有字段都只具有单一属性
* 单一属性的列由基本的数据类型所构成的
* 设计出来的表都是简单的二维表

数据库设计的第二范式

* 要求一个表中具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对部分主键的依赖关系

数据库设计的第三范式

* 指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。


需求分析及逻辑注册

用户登陆及用户管理功能

* 用户必须注册并登陆系统才能进行网上交易
* 同一时间一个用户只能在一个地方登陆
* 用户信息： 用户名，密码，手机号，姓名，注册日期，在线状态，出生日期

商品展示及商品管理功能

* 商品信息： 商品名称，分类名称，出版社名称，图书价格，图书描述，作者
* 分类信息：分类名称，匪类描述
* 商品分类：商品名称，分类名称

供应商管理功能

* 供应商信息：出版社名称，地址，电话，联系人，银行账号

在线销售功能

* 在线销售：订单编号
* 订单表：订单编号，下单用户名，下单日期，支付金额，物流单号
* 订单商品关联表：订单编号，订单商品分类，订单商品名，商品数量